
%
%  $Description: Author guidelines and sample document in LaTeX 2.09$ 
%
%  $Author: ienne $
%  $Date: 1995/09/15 15:20:59 $
%  $Revision: 1.4 $
%

\documentclass[times, 10pt,twocolumn]{article} 
\usepackage{latex8}
\usepackage{times}
\usepackage[german]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{breakurl}
\usepackage{color}

%for jDoc (begin)
\usepackage{ifthen}
\usepackage{arrayjob}
\makeatletter
\usepackage{trimspaces}
\usepackage{titlesec}
\def\trimspace#1{\trim@spaces@in{#1}}
\makeatother
\input{jDoc}
%for jDoc (end)

%Format Listings
\definecolor{javared}{rgb}{0.6,0,0} % for strings
\definecolor{javagreen}{rgb}{0.25,0.5,0.35} % comments
\definecolor{javapurple}{rgb}{0.5,0,0.35} % keywords
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % javadoc

\lstset{language=Java,
basicstyle=\ttfamily,
keywordstyle=\color{javapurple}\bfseries,
stringstyle=\color{javared},
commentstyle=\color{javagreen},
morecomment=[s][\color{javadocblue}]{/**}{*/},
numbers=left,
numberstyle=\tiny\color{black},
stepnumber=1,
numbersep=10pt,
tabsize=4,
showspaces=false,
showstringspaces=false,
frame=single}


%------------------------------------------------------------------------- 
% take the % away on next line to produce the final camera-ready version 
\pagestyle{empty}

%------------------------------------------------------------------------- 
\begin{document}

\title{Java 7 - State of the Art}

\author{Jonas Traub\\
Duale Hochschule Baden-Württemberg\\
Stuttgart, Deutschland\\
jonastraub@gmail.com
\and
Matthis Hauschild\\
Duale Hochschule Baden-Württemberg\\
Stuttgart, Deutschland\\
matthis.hauschild@gmail.com\\
}

\maketitle
\thispagestyle{empty}

\begin{abstract}
TODO 
\end{abstract}

\Section{Introduction}

\Section{Diamond Operator}
Mit Java 5 wurden Generics in die Sprache eingeführt, die sich schnell großer Beliebtheit erfreut haben und von der Entwicklergemeinde sehr gut angenommen wurden. Nun mit Java 7 hat Oracle die Deklaration von Variablen mit Generics deutlich vereinfacht\cite{oracleJavaRel}.\\

Noch in Java 6 musste der Typ in Generics einer Deklaration mehrfach angegeben werden.
\begin{lstlisting}[language=java,breaklines=true]
  List<Integer> name = new ArrayList<Integer>();
  Map<Integer,List<String>> name2 = new Map<Integer,List<String>>();
\end{lstlisting}
Java 7 unterstützt nun das automatische Rückschließen auf den deklarieren Datentyp bei der initialisierung.\cite{v2bJava7} Statt der erneuten Angabe des Typs kann hier nun der Diamantoperator verwendet werden.
\begin{lstlisting}[language=java,breaklines=true]
  List<Integer> = new ArrayList<>();
  Map<Integer,List<String>> name2 = new Map<>();
\end{lstlisting}
Insbesondere bei verschachtelten Deklarationen ist dieses Feature in Verbindung mit der Autovervollständigung einer IDE sehr nützlich. Der Diamantoperator kann auch verwendet werden, wenn Initialisierung und Deklaration nicht in der selben Codezeile erfolgen.\cite{v2bJava7}\\

Auch die Verwendung in Verbindung mit dem Wildcardoperator wurde ermöglicht.
\begin{lstlisting}[language=java,breaklines=true]
  List<? extends Number> = new ArrayList<>();
\end{lstlisting}
Es wird hier bei der Initialisierung immer auf die Höchste mögliche Klasse zurück geschlossen. Im konkreten Beispiel also auf \jd{Number}.\cite{v2bJava7}

\Section{try-with-resources}
Neu mit Java 7 ist \texttt{try-with-resources}, was die normale try-catch-finally Routine erweitert,
um die beiden folgenden Probleme zu adressieren:\cite{javainsel2}
\begin{enumerate}
\item Das Schließen einer Ressource benötigt oft ein zusätzliches try-catch
\item Eine Ausnahme im finally-Block überdeckt eine etwaige Ausnahme aus dem try-Block
\end{enumerate}

Mit Ressourcen sind hier alle Klassen gemeint, die die neue Schnittstelle \jd{AutoClosable} implementieren, wie beispielsweise
InputBuffer- und OutputBuffer-Klassen, aber auch die JDBC-Klassen \jd{Connection}, \jd{Statement} und \jd{ResultSet}.

Um \texttt{try-with-resources} nutzen zu können, wird die Syntax des \texttt{try}s um einen Anweisungsblock in runden Klammern erweitert,
in dem nun alle, am Ende zu schließenden, Ressourcen initialisiert werden. Das folgende Beispiel illustriert den Unterschied zwischen der
klassischen Variante des manuellen Schließens der geöffneten Ressourcen sowie der neuen Variante mit \texttt{try-with-resources}:

\begin{lstlisting}[language=java,breaklines=true]
Connection con = null;
Statement stmt = null;
ResultSet rs = null;

try {
  con = DriverManager.getConnection(
	"jdbc:hsqldb:file:/tmp/hsql;shutdown=true", "root", "");
  stmt = con.createStatement();
  rs = stmt.executeQuery("SELECT * FROM Customer");
  while (rs.next()) {
	System.out.printf("%s, %s%n", rs.getString(1), rs.getString(2));
  }
} catch (SQLException e) {
  e.printStackTrace();
} finally {
  try {
	if (rs != null) rs.close();
  } catch (SQLException e) {
	e.printStackTrace();
  } finally {
	try {
	  if (stmt != null)	stmt.close();
	} catch (SQLException e) {
	  e.printStackTrace();
	} finally {
	  try {
		if (con != null) con.close();
	  } catch (SQLException e) {
		e.printStackTrace();
} } } }
\end{lstlisting}

Es ist zu erkennen, dass, um alle drei Ressourcen sicher schließen zu können, drei ineinander verschachtelte try-catch-finally Blöcke
gebraucht werden. Ein weiterer Nachteil dieser Lösung ist das Verschlucken einer Exception, wenn gleichzeitig in Zeile 2 sowie in einer
der \texttt{close()}-Methoden eine Exception geworfen wird. Dann überdeckt die Exception der \texttt{close()}-Anweisung die andere und der
Anwender bekommt sie niemals zu Gesicht.\cite{javainsel2}

\begin{lstlisting}[language=java,breaklines=true]
try (
  Connection con = DriverManager.getConnection(
	"jdbc:hsqldb:file:/tmp/hsql;shutdown=true", "root", ""
  );
  Statement stmt = con.createStatement();
  ResultSet rs = stmt.executeQuery("SELECT * FROM Customer");
) {
  while (rs.next()) {
	System.out.printf("%s, %s%n", rs.getString(1), rs.getString(2));
  }
} catch (SQLException e) {
  e.printStackTrace();
}
\end{lstlisting}

Bei \texttt{try-with-resources} kann man alle Ressourcen (die \jd{AutoClosable} implementieren) mit Semikola getrennt 
nach dem \texttt{try} auflisten. Damit werden sie automatisch am Ende des Blocks geschlossen und falls mehrere Exceptions auftreten,
werden alle an den Anwender hochgereicht. Wie das genau gemacht wird, wird in Kapitel \ref{supp_exception_subsec} erläutert. 

\Section{Literals}
\SubSection{Binary Literals}

Während in der bisherigen Javaversion 6 Zahlenliterale nur in oktaler, dezimaler und hexadezimaler angabeform möglich waren, erlaubt java 7 nun auch Binäre literale. Binäre Literale können mit dem Präfix \texttt{0b} geschrieben werden.

Insbesondere bei der Angabe negativer Zahlen ist jedoch Vorsicht geboten. Für die Datentypen \texttt{byte} und \texttt{short} kann das erste Bit nicht direkt angegeben werden. Es sind also nur 7 bzw. 15 statt 8 und 16 Bit lange Angaben möglich. Die Angabe ob es sich um eine Negative Zahl handelt erfolgt hier durch ein Minuszeichen. Zu beachten ist jedoch, dass der Wert der Binärzahl dadurch negativ dargestellt wird. Dies ist nicht Äquivalent mit einer Invertierung des Vorzeichenbits, was Zeilen 1-3 des folgenden Beispiels verdeutlichen.\cite{sbJ7literals}
\begin{lstlisting}[language=java,breaklines=true]
  byte zahl1 =  0b1111111  // 127
  byte zahl2 = -0b1111111  //-127
  byte zahl3 = -0b10000000 //-128
  byte zahl4 =  0b01111111 // 127
  byte zahl5 =  0b10000000 //ERROR
\end{lstlisting}
Auffallend ist nun noch dass führende Nullen ignoriert werden (Zeile 4), wenn hingegen ein gleich langes Literal den Wertebereich des Datentyps überschreitet führt dies zu einem Compilererror (Can not convert from int to byte)\cite{sbJ7literals}.\\

Beim Datentyp \texttt{int} gelten inkonsistenter Weise andere Regeln. Werden bei einem \texttt{int} die vollen 32 Bit angegen, wird das linkeste Bit als Vorzeichenbit interpretiert. Es kommt nicht zu einem Compilererror. Die zusätzliche Angabe den Minus Vorzeichens führt jedoch auch hier zu einer direkten Negativdastellung des Zahlenwerts und nicht zur Invertierung der des Vorzeichenbits. Erst ab dem 33 Bit kommt es zu einem Compilererror (out of range).
\begin{lstlisting}[language=java,breaklines=true]
int i=
 0b1000000000000000_0000000000000000;
 //-2147483648
int j=
 -0b1000000000000000_0000000000000000;
 //-2147483648
int k=
 0b1010101010101010_1010101010101010;
 //-1431655766
int l=
 -0b1010101010101010_1010101010101010;
 // 1431655766
int m=
 0b0010101010101010_1010101010101010;
 // 715827882
int n=
 -0b0010101010101010_1010101010101010;
 //-715827882
\end{lstlisting}

Verwunderlich ist hier zunächst das zweite Beispiel. Trotz des zusätzlichen Vorzeichens ist das Erbegnis identisch. Das Vorzeichen negiert den Zahlenwert. Erwarten würden wir also das Ergebnis \texttt{2147483648}. Da dies jedoch außerhalb des Wertebereichs von \texttt{int} liegt kommt ein Overflow um \texttt{1} hinzu. Ergebnis ist somit wieder \texttt{-2147483648}.

\SubSection{Underscores in Numeric Literals}
JONAS - S.42 J7 Buch fail

\Section{Strings in switch Statements}
MATTHIS

\Section{Generic in Varargs}
JONAS

\Section{Exceptions}
\SubSection{Catch Multiple Exceptions at once}
MATTHIS

\SubSection{Suppressed Exceptions}\label{supp_exception_subsec}

\Section{NIO.2}
MATTHIS

\Section{ForkJoin-Framework}
JONAS

\Section{Conclusion}

% \SubSection{Bla}
% Sample Subsection
% 
% \begin{figure}[h]
%    \caption{Example of caption.}
% \end{figure}
% 
% \noindent Long captions should be set as in 
% \begin{figure}[h] 
%    \caption{Example of long caption requiring more than one line. It is 
%      not typed centered but aligned on both sides and indented with an 
%      additional margin on both sides of 1~pica.}
% \end{figure}
% 
% \SubSection{Footnotes}
% 
% Please use footnotes sparingly%
% \footnote
%    {%
%      Or, better still, try to avoid footnotes altogether.  To help your 
%      readers, avoid using footnotes altogether and include necessary 
%      peripheral observations in the text (within parentheses, if you 
%      prefer, as in this sentence).
%    }
% and place them at the bottom of the column on the page on which they are 
% referenced. Use Times 8-point type, single-spaced.
% 
% \SubSection{References}
% 
% List and number all bibliographical references in 9-point Times, 
% single-spaced, at the end of your paper. When referenced in the text, 
% enclose the citation number in square brackets, for example~\cite{javainsel2}. 
% Where appropriate, include the name(s) of editors of referenced books.
% 
% %------------------------------------------------------------------------- 
% \SubSection{Illustrations, graphs, and photographs}
% 
% All graphics should be centered. Your artwork must be in place in the 
% article (preferably printed as part of the text rather than pasted up). 
% If you are using photographs and are able to have halftones made at a 
% print shop, use a 100- or 110-line screen. If you must use plain photos, 
% they must be pasted onto your manuscript. Use rubber cement to affix the 
% images in place. Black and white, clear, glossy-finish photos are 
% preferable to color. Supply the best quality photographs and 
% illustrations possible. Penciled lines and very fine lines do not 
% reproduce well. Remember, the quality of the book cannot be better than 
% the originals provided. Do NOT use tape on your pages!

%------------------------------------------------------------------------- 
\bibliographystyle{latex8}
\bibliography{../stateofart}

\jDocIndex

\end{document}

